

float length_squared(vec3 v) {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}


float length(vec3 v) {
    return sqrt(length_squared(v));
}

vec3 unit_vector(vec3 v) {
    float length = length(v);
    return vec3(v.x / length, v.y / length, v.z / length);
}


//// random
float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 rand_vec3(float min, float max, float seed) {
    float randX = mix(min, max, rand(gl_FragCoord.xy + seed));
    float randY = mix(min, max, rand(gl_FragCoord.yx + seed));
    float randZ = mix(min, max, rand(gl_FragCoord.yx * 0.5 + seed)); // Use a different seed for Z

    return vec3(randX, randY, randZ);
}

vec3 random_in_unit_sphere(float seed) {
    float init_seed = sqrt(seed/1000); // ?

    while (true) {
        vec3 rand_vec3 = rand_vec3(0, 1, init_seed);

        if (length_squared(rand_vec3) < 1)
            return rand_vec3;

        init_seed += 10.0;
    }
}


vec3 random_unit_vector(float seed) {
    return unit_vector(random_in_unit_sphere(seed));
}

vec3 random_on_hemisphere(vec3 normal, float seed) {
    vec3 on_unit_sphere = random_unit_vector(seed);
    if (dot(on_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return on_unit_sphere;
    else
        return -on_unit_sphere;
}
///////////////
